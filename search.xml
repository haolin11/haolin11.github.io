<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++碎片(二)</title>
      <link href="/2022/12/28/C-%E7%A2%8E%E7%89%87-%E4%BA%8C/"/>
      <url>/2022/12/28/C-%E7%A2%8E%E7%89%87-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="关于多线程">关于多线程</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++新特性</title>
      <link href="/2022/12/14/C-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/12/14/C-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="c可变参数模板">C++可变参数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//函数出口，变参本质上像递归，最后没有参数时执行f()，所以需要出口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>...Args&gt;    </span><br><span class="line">    <span class="comment">//变参模板格式class...Args，包括后面的Args...args</span></span><br><span class="line">    <span class="comment">//想要一个一个操作参数则需  class T——T t</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t, Args...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; t &lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>...(args)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//t为输入的第一个参数（sizeof...查看参数个数）</span></span><br><span class="line">    <span class="built_in">f</span>(args...);    <span class="comment">//剩下的参数递归调用，最后没参数调用出口函数f()</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="string">&quot;%%&amp;*$&quot;</span>,<span class="number">2.3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++<strong>可变参数模板</strong>本质上像递归，所以调用到最后无参，需要出口函数。</p><p>值得注意的是<strong>模板函数需要实例化才能被调用</strong>，如果想用<strong>if</strong>语句代替出口函数，下面是一个<strong>错误的</strong>用法（注释有正解）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>...Args&gt;    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t, Args...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; t &lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>...(args)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//t为第一个参数，会实例化出T的类型（sizeof...查看参数个数）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//if编译时还会显示出不符合条件的分支，会产生f()</span></span><br><span class="line">    <span class="comment">//而f()没有参数模板无法实例化，所以会报无匹配f()</span></span><br><span class="line">    <span class="comment">//可以使用if constexpr，编译时去掉不符合条件的分支！</span></span><br><span class="line">        <span class="comment">//正确用法为if constexpr(sizeof...(args) &gt; 0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可变参模板也可<strong>传函数</strong>（相当于函数指针做变量）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">call</span><span class="params">(F fuc, Args...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fuc</span>(args...);</span><br><span class="line">    <span class="comment">//此例无返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">call</span>([](<span class="type">int</span> a, std::string str)&#123;std::cout&lt;&lt;a&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;str&lt;&lt;std::endl;&#125;, <span class="number">5</span>, <span class="string">&quot;gyduebc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户自定义字面量">用户自定义字面量</h2><p>一定要用**_<strong>xx，不用下划线的是系统的字面量重载“”函数，</strong>用户自定义的一定要用下划线**，并且形参类型有限制，具体见<ahref="https://zh.cppreference.com/w/cpp/language/user_literal">用户自定义字面量</a></p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221223203850645.png" /></p><p>此处一定要有size_t类型参数，不然会报错（因为没有计数参数时，字符数组指针无法知道字符数组长度，也就无从操作）</p><p>字符串自动计算了长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span>_q(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;str&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;size&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="string">&quot;fes1314rwffg&quot;</span>_q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fes1314rwffg  12</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++碎片(一)</title>
      <link href="/2022/12/07/C-%E7%A2%8E%E7%89%87-%E4%B8%80/"/>
      <url>/2022/12/07/C-%E7%A2%8E%E7%89%87-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="关于c头文件">关于C++头文件</h2><h3 id="导入符号使用细节">导入符号使用细节</h3><p><strong>"xxx.h"</strong>和<strong>&lt;xxx.h&gt;</strong>都用于包含头文件（在编译器包含正确路径的前提下），<strong>"xxx.h"</strong>优先从代码include文件（文件夹）中查找；<strong>&lt;xxx.h&gt;</strong>优先从计算机已安装库里查找（如：Linux系统中/include; /local/include）</p><p>此外常用的<strong>"xxx.h"</strong>可用作相对位置查找（比较实用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/Log/Log.h&quot;</span></span></span><br><span class="line"><span class="comment">//表示从当前文件的上一级目录下的include/Log/中查找Log.h</span></span><br></pre></td></tr></table></figure><h3 id="避免重复导入">避免重复导入</h3><p>常用形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//XXX</span></span><br><span class="line"><span class="comment">//XXX</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可用简洁形式 <strong>#pragma once</strong> 代替（推荐）</p><p>检查重复导入作用，例如：在头文件中构造一个结构体，若不做重复导入避免处理，会报重定义错误。</p><h2 id="关于软件调试">关于软件调试</h2><p>代码调试前提是需要生成<strong>DEBUG模式</strong>的<strong>可执行文件</strong>。调试核心是<strong>断点</strong>和<strong>读内存</strong>。</p><h3 id="断点">断点</h3><p><strong>breakpoint</strong>设置断点后，运行代码，程序会在第一个断点处暂停。注意此时<strong>断点行程序未被执行，是将要被执行</strong>。步进执行代码的黄色箭头也是如此，箭头所在行是将要被执行。</p><h3 id="以visual-studio为例">以Visual Studio为例</h3><p>设置Debug模式并运行调试程序</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209153629908.png#pic_center"alt="设置Debug模式并运行" /><figcaption aria-hidden="true">设置Debug模式并运行</figcaption></figure><p><strong>Continue</strong>继续执行到下一个断点或结尾；<strong>Stepinto</strong>进入函数内部；<strong>Stepover</strong>跳到下一行；<strong>Step out</strong>跳出当前函数</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209154041588.png#pic_center"alt="Continue、Step into、Step over、Step out" /><figcaption aria-hidden="true">Continue、Step into、Step over、Stepout</figcaption></figure><p>调试运行后可以查看所有变量的值以及内存地址、内存中存储的值（以16进制显示，两位为一字节），鼠标停留可显示值。注意：若断点行是初始化赋值操作，代码运行到断点处该变量为未初始化状态（还未执行该行代码！）。在VisualStudio中DEBUG模式会为所有未初始化变量赋值0xCCCCCCCC（便于直观监控内存）（也就是十进制-858993460）</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209161151365.png#pic_center"alt="未初始化内存" /><figcaption aria-hidden="true">未初始化内存</figcaption></figure><p>autos、locals、watch窗口，展示变量、局部变量的值，监视变量的值（watch自己添加需要监视的变量）。字符串一般会同时显示地址和值。</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209163110579.png#pic_center"alt="watch窗口" /><figcaption aria-hidden="true">watch窗口</figcaption></figure><p>菜单Debug-&gt;windows-&gt;memory-&gt;memory1查看内存存储情况。（&amp;a表示取变量a地址，回车查看内存）</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209163537333.png#pic_center"alt="查看内存" /><figcaption aria-hidden="true">查看内存</figcaption></figure><h3 id="debug时跳出循环">Debug时跳出循环</h3><p>注意跳出循环不能用Stepout！这会直接跳出当前函数。可以在循环结束的下一句设置一个有效断点，然后运行Continue（可以在Debug运行中进行）。</p><h2 id="关于源码阅读">关于源码阅读</h2><p>先运行代码查看代码具体功能，然后看每个文件夹大致的作用（通过浏览文件夹名称以及所包含的文件名），最后查看类视图以及DEBUG设置合适断点查看栈帧。</p><h3 id="以visual-studio为例-1">以Visual Studio为例</h3><p>查看类视图</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209165144741.png#pic_center"alt="类视图查看步骤1" /><figcaption aria-hidden="true">类视图查看步骤1</figcaption></figure><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209165341325.png#pic_center"alt="类视图查看步骤2" /><figcaption aria-hidden="true">类视图查看步骤2</figcaption></figure><p>类视图效果（继承关系、函数重写、成员变量、成员函数）</p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209165454742.png#pic_center"alt="类视图效果" /><figcaption aria-hidden="true">类视图效果</figcaption></figure><h4 id="调用堆栈">调用堆栈</h4><p>设置断点查看调用堆栈，看<strong>函数调用的由来</strong></p><figure><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221209165828187.png#pic_center"alt="调用堆栈" /><figcaption aria-hidden="true">调用堆栈</figcaption></figure><h2 id="关于循环">关于循环</h2><p><strong>for</strong>和<strong>while</strong>没有特定的区分，看习惯使用。但通常需要经常改变某些变量，如遍历等操作用<strong>for</strong>；需要一直循环，只在<strong>某些不常变条件</strong>改变才终止循环的情况用<strong>while</strong>。</p><h3 id="控制流语句">控制流语句</h3><p>循环经常搭配<strong>控制流语句</strong>使用：<strong>continue</strong>、<strong>break</strong>、<strong>return</strong>，前两个只对循环起作用，后一个直接结束函数。</p><p><strong>continue</strong>：只能对循环使用。如果还有下一次迭代的话，表示进入下一次迭代，如果没有，循环就结束。</p><p><strong>break</strong>：主要用于循环，也出现在switch语句中。表示跳出（终止）循环。</p><p><strong>return</strong>：可以在任何地方，直接跳出当前函数。视当前函数返回值而定（返回void可以只写一个return）。</p><h2 id="关于面向对象">关于面向对象</h2><p>比如一个游戏程序：我们要定义玩家1、玩家2、······，当<strong>不使用面向对象编程时</strong>会十分麻烦，要定义很多变量；对其操作也需要定义很多形参。就像下面的代码一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//xxxxxxxxxx;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> PlayerX0, PlayerY;</span><br><span class="line">    <span class="type">int</span> PlayerSpeed = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> PlayerX1, PlayerY;</span><br><span class="line">    <span class="type">int</span> PlayerSpeed = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用面向对象编程</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:        <span class="comment">//注意类的可见性，不设置则只能由public类成员函数访问类成员变量！</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">&#125;;            <span class="comment">//注意有分号，和结构体struct一样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(Player&amp; player, <span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//引用传值和指针一样，可以改变实参的内存值。（比指针简单明了，推荐）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    player.x += xa * player.speed;</span><br><span class="line">    player.y += ya * player.speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    player.y = <span class="number">3</span>;</span><br><span class="line">    player.speed = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Move</span>(player, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Player playerX0;</span><br><span class="line">    Player playerX1;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();    <span class="comment">//暂停控制台</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法也可写入对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在函数内部就不需要传递对象了，直接使用对象的成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x = <span class="number">5</span>;</span><br><span class="line">    player.y = <span class="number">3</span>;</span><br><span class="line">    player.speed = <span class="number">2</span>;</span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Player playerX0;</span><br><span class="line">    Player playerX1;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数进一步简化对象初始化过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line">    <span class="comment">//注意构造函数的可见性！</span></span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">int</span> x_, <span class="type">int</span> y_, <span class="type">int</span> speed_):<span class="built_in">x</span>(x_), <span class="built_in">y</span>(y_), <span class="built_in">speed</span>(speed_)&#123;&#125;</span><br><span class="line">    <span class="comment">//注意一旦写了自定义构造函数，默认构造函数就失效了，需要用的化需要再写一个！</span></span><br><span class="line">    <span class="built_in">Player</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在函数内部就不需要传递对象了，直接使用对象的成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Player <span class="title">player</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>;    <span class="comment">//初始化一行搞定，一切为了简洁</span></span><br><span class="line">    <span class="comment">//player.x = 5;</span></span><br><span class="line">    <span class="comment">//player.y = 3；</span></span><br><span class="line">    <span class="comment">//player.speed = 2;</span></span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Player playerX0;       <span class="comment">//不自己再添加默认无参构造的话会报错的</span></span><br><span class="line">    Player playerX1;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上类是把一堆东西<strong>打包</strong>在一起了，并设置读写权限，所以有时我们可以灵活运用对象成员变量。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将类型赋予名字，提高可读性</span></span><br><span class="line">    <span class="comment">//最好用枚举enum Color &#123; Red, Green, Blue &#125;;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Red = <span class="number">0</span>;      </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Green = <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Blue = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_ColorType = <span class="number">0</span>;      <span class="comment">//默认为红色；一般用m_表示私有</span></span><br><span class="line">    <span class="comment">//可用枚举Color m_ColorType = Red;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">int</span> x_, <span class="type">int</span> y_, <span class="type">int</span> speed_):<span class="built_in">x</span>(x_), <span class="built_in">y</span>(y_), <span class="built_in">speed</span>(speed_)&#123;&#125;</span><br><span class="line">    <span class="built_in">Player</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColorType</span><span class="params">(<span class="type">int</span> colortype)</span>  <span class="comment">//形参可用枚举类型Color</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ColorType = colortype;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;ColorType: &quot;</span>&lt;&lt;m_ColorType&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Player <span class="title">player</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>; </span><br><span class="line">    <span class="comment">//player.x = 5;</span></span><br><span class="line">    <span class="comment">//player.y = 3；</span></span><br><span class="line">    <span class="comment">//player.speed = 2;</span></span><br><span class="line">    player.<span class="built_in">setColorType</span>(player.Green);    <span class="comment">//用自己的成员变量来设置</span></span><br><span class="line">    <span class="comment">//枚举依然可以使用player.Green；最好用Player::Green</span></span><br><span class="line">    player.<span class="built_in">Move</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Player playerX0; </span><br><span class="line">    Player playerX1;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();  <span class="comment">//暂停控制台</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于静态变量static">关于静态变量static</h2><p>分为两类：<strong>类外</strong>static和<strong>类内</strong>static</p><h3 id="类外static">类外static</h3><p><strong>类外</strong>static意味着此变量<strong>只对其所在文件可见</strong>，重点：谨慎使用全局变量，尽量让函数和变量标记为静态的，除非真的需要它们跨文件（跨翻译单元）链接。或者<strong>使用命名空间</strong>。</p><h3 id="类内static">类内static</h3><p><strong>类内</strong>static意味着该变量将<strong>与类的所有实例共享内存</strong>，众多实例对象中该<strong>静态变量只有一个实例</strong>。</p><p>包括静态方法也是如此，但<strong>类内静态方法</strong>在<strong>实例化前就可以使用</strong>，且<strong>只能</strong>访问类中的<strong>静态成员（方法或属性）</strong>（因为<strong>静态方法没有类实例</strong>）。</p><p><strong>类内</strong>static静态成员差不多<strong>不属于类</strong>了，<strong>需要在类外定义</strong>，不然会报错（方法其实不必须，因为不涉及内存。但依然可以作为习惯）<strong>。</strong></p><p><strong>可以将类内static静态成员理解为是在一个命名空间（类名）中声明了一个变量或方法</strong>，区别是但它们依然可以设置public或private可见性（如静态成员变量私有，仅通过共有静态成员函数访问）。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Staticvar</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; x &lt;&lt; y &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Staticvar::x = <span class="number">10</span>;     <span class="comment">//全局区分配内存</span></span><br><span class="line"><span class="type">int</span> Staticvar::y;     <span class="comment">//注意此时不用static关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Staticvar::<span class="built_in">hello</span>();    <span class="comment">//静态成员函数当命名空间下函数使用</span></span><br><span class="line">    std::cout&lt;&lt;Staticvar::x&lt;&lt;Staticvar::y&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部作用域内的static">局部作用域内的static</h3><p><strong>{}</strong>作用域内（比如函数内）的static静态变量，意味着该变量<strong>只局部可见，但生命周期为整个程序运行过程。（类似于一个全局变量，但仅所处局部作用域内可见）（只初始化一次）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//只执行一次初始化</span></span><br><span class="line">    i++;</span><br><span class="line">    std::cout&lt;&lt; i &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();   </span><br><span class="line">    <span class="comment">//结果输出1 2 3 4，而不是1 1 1 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例类">单例类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//使用复制的话可以不用static，但这样占内存</span></span></span><br><span class="line"><span class="function">    <span class="comment">//故返回值使用静态变量，接收用 &amp;</span></span></span><br><span class="line"><span class="function">    <span class="comment">//函数用static表明函数可用类直接调用，该函数不属于任何类实例</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//通过static延长单例的生命周期</span></span><br><span class="line">        <span class="comment">//因为不用static单例内存在栈上,返回栈上变量大有问题！</span></span><br><span class="line">        <span class="type">static</span> singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;success!&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    singleton::<span class="built_in">Get</span>().<span class="built_in">hello</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部类">局部类</h3><p><strong>注意</strong>定义在<strong>函数内或者{}作用域内</strong>的叫<strong>局部类</strong>，局部类<strong>可以有静态成员函数</strong>，但<strong>不能有静态成员变量</strong>。<strong>（函数内的内存在堆栈上（局部静态变量除外），而静态成员变量在编译时就要分配空间，在全局数据区。编译时不知道有该局部类，所以无法分配局部类下的静态内存）</strong></p><h2 id="关于构造函数">关于构造函数</h2><p>如果<strong>不希望创建的类实例化对象</strong>，则可以把<strong>构造函数设置为private</strong>私有函数（此时创建对象会报错）。或者将函数=delete；如对于Log类，公有属性中加<strong>Log() = delete;</strong> 即可。</p><h2 id="关于继承">关于继承</h2><p>注意：private私有成员变量或成员函数，即使子类用public公有继承也无法访问。（因为private只有自己或友元可以访问）。所以就有了protect，可以自己、友元或者子类中访问，但类外不可访问。</p><h3 id="虚函数">虚函数</h3><p>使用<strong>虚函数</strong>时，父类在<strong>函数前</strong>用<strong>virtual</strong>关键字，子类重写在<strong>函数后</strong>使用<strong>override</strong>关键字（可以不用，但用会更清楚）</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20221222172954049.png" /></p><h3 id="接口纯虚函数">接口（纯虚函数）</h3><p>（虚函数 =0；）纯虚函数也称为接口，必须在子类中进行重写才能实例化对象。</p><h2 id="关于智能指针">关于智能指针</h2><p>都建议使用std::unique_ptr&lt; &gt; xx = std::make_unique&lt; &gt;() /std::shared_ptr&lt; &gt; xx = std::make_shared&lt; &gt;() /weak_ptr用shared_ptr赋值。注意包含头文件<memory></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sherad_e0;</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_ptr&lt;<span class="type">int</span>&gt; unique_e1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            std::shared_ptr&lt;<span class="type">int</span>&gt; shared_e2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">            sherad_e0 = shared_e2;</span><br><span class="line">            std::weak_ptr&lt;<span class="type">int</span>&gt; weak_e3 = sherad_e0;</span><br><span class="line">        &#125;    <span class="comment">//unique_ptr死</span></span><br><span class="line">    &#125;    <span class="comment">//shared_ptr死，weak_ptr也死</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unique_ptr">unique_ptr</h3><p><strong>首选unique_ptr</strong>（作用域指针，出作用域即死，释放内存）（所以不能进行指针复制，不能两个unique_ptr指向一个内存，不然有重复释放风险（已删除拷贝构造和=复制，使用即报错））</p><h3 id="shared_ptr">shared_ptr</h3><p>需要拷贝指针时（如函数传参等）则<strong>使用shared_ptr</strong>（可以多个shared_ptr指向同一块内存，使用引用计数，最后一个指针出作用域才死）</p><h3 id="weak_ptr">weak_ptr</h3><p><strong>weak_ptr</strong>可以复制shared_ptr，但不影响引用计数，所以<strong>不影响内存生死</strong>。</p><h2 id="关于函数传值">关于函数传值</h2><p>请总是用<strong>const XXX &amp;常引用</strong>传值，这会优化程序性能（并且<strong>可以接收临时右值</strong>），可以<strong>在函数内部决定要不要copy</strong>，让copy发生在函数内部而不是传值的时候！</p><h2 id="获取类成员变量的内存偏移量">获取类成员变量的内存偏移量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vector3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, z, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> offset = (<span class="type">long</span>) &amp;((vector3*)<span class="number">0</span>)-&gt;z;</span><br><span class="line">    <span class="comment">//32位系统可以把指针转为int</span></span><br><span class="line">    <span class="comment">//即int offset = (int) &amp;((vector3*)nullptr)-&gt;z;</span></span><br><span class="line">    std::cout&lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出4 </span></span><br></pre></td></tr></table></figure><h2 id="避免stdvector复制使用优化">避免std::vector复制（使用优化）</h2><p>没有使用预分配内存 <strong>.reserve(n)</strong> 和<strong>emplace_back</strong> 时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vertex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">    <span class="built_in">vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z)</span><br><span class="line">    :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;z = z;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vertex</span>(<span class="type">const</span> vertex&amp; v)  <span class="comment">//拷贝构造</span></span><br><span class="line">    :<span class="built_in">x</span>(v.x), <span class="built_in">y</span>(v.y), <span class="built_in">z</span>(v.z)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;copied!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);    </span><br><span class="line">    <span class="comment">//隐式转换再复制</span></span><br><span class="line">    <span class="comment">//容积为1，复制一次</span></span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));    </span><br><span class="line">    <span class="comment">//构造（也有int-&gt;float的隐式转换），然后复制</span></span><br><span class="line">    <span class="comment">//新分配容积2，旧内存复制到新内存 + 新插入，复制两次</span></span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">push_back</span>(<span class="built_in">vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="comment">//新分配容积3，旧内存复制到新内存 + 新插入，复制三次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//总共复制6次，输出：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预分配内存emplace_back">预分配内存+emplace_back</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vertex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">    <span class="built_in">vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z)</span><br><span class="line">    :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;z = z;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vertex</span>(<span class="type">const</span> vertex&amp; v)  <span class="comment">//拷贝构造</span></span><br><span class="line">    :<span class="built_in">x</span>(v.x), <span class="built_in">y</span>(v.y), <span class="built_in">z</span>(v.z)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;copied!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;vertex&gt; vertices;</span><br><span class="line">    vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);   <span class="comment">//不需反复扩容，本例少3次copy</span></span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    </span><br><span class="line">    <span class="comment">//直接在内存里构造，没有复制</span></span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); </span><br><span class="line">    </span><br><span class="line">    vertices.<span class="built_in">emplace_back</span>(<span class="built_in">vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">    <span class="comment">//这种构造与 push_back 一样，复制一次</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">//总共复制1次，输出：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    copied!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于处理多返回值">关于处理多返回值</h2><p>可以使用c++的特定类型<strong>tuple、pair</strong>等进行返回，但其取值不直观（.first.second不能直观表达变量含义），或者可以使用<strong>引用传参、指针传参</strong>，但其传参参数太多（不简洁），同类型可以返回<strong>数组或vector</strong>（但仅限于同类型）。</p><h3 id="struct返回">struct返回</h3><p>故推荐<strong>使用struct（或聚合类）进行返回</strong>，类中成员变量可按需命名，并随意添加，最后返回可用大括号<strong>{}</strong>，因为聚合类可用大括号赋值，十分方便明了。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Retpara</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> speed;</span><br><span class="line">    <span class="type">float</span> posititon;</span><br><span class="line">    std::string carName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Retpara <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> fspeed = <span class="number">1.f</span>;</span><br><span class="line">    <span class="type">float</span> fposititon = <span class="number">2.f</span>;</span><br><span class="line">    std::string fcarName = <span class="string">&quot;mycar&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;fspeed, fposititon, fcarName&#125;;</span><br><span class="line">    <span class="comment">//返回方便直观</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">float</span> pspeed, <span class="type">float</span> pposition, std::string pcarName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;pspeed&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;pposition&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;pcarName&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Retpara</span> retpara = <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">print</span>(retpara.speed, retpara.posititon, retpara.carName);</span><br><span class="line">    <span class="comment">//传参方便直观</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    mycar</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于模板template">关于模板template</h2><p>模板不仅可以在编译时根据调用代码实例化函数，类等，还可以在编译时根据调用确认参数值，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; array;    </span><br><span class="line">    <span class="comment">//调用编译时生成具体类代码，无调用不生成类</span></span><br><span class="line">    <span class="comment">//调用编译时确认参数值</span></span><br><span class="line">    std::cout &lt;&lt; array.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//输出：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码相当于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_array[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(m_array)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>&gt; array;</span><br><span class="line">    std::cout &lt;&lt; array.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//输出：5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意，如果类内部用<strong>int size =5;</strong>等语句时，这时候不是初始化，是<strong>设置构造对象时的默认值</strong>。这时候size并<strong>没有分配内存</strong>，并没有值（除静态成员变量外，类不能分配内存），所以<strong>不能用size去给内部别的变量赋值</strong>，如下代码就是<strong>错的</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//！！！错的用法！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">    T m_array[size];  </span><br><span class="line">    <span class="comment">//此时size并没有值，所以该用法是错的</span></span><br><span class="line">    <span class="comment">// error: invalid use of non-static data member ‘Array::size’</span></span><br><span class="line">    <span class="comment">// |     T m_array[size];</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(m_array)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于宏">关于宏</h2><p>常用于调试，调试模式下可以向控制台输出一些信息，发布模式则可自动删除打印信息等调试代码（最好define时给一个值）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_DEBUG 1  </span></span><br><span class="line"><span class="comment">//可以在编译时define</span></span><br><span class="line"><span class="comment">//实现一个值自动改变代码构成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PR_DEBUG == 1  </span></span><br><span class="line"><span class="comment">//预处理主要针对#内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//#elif defined(PR_RELEASE)  //推荐</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) <span class="comment">//定义为空</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="comment">//#define PR_DEBUG 1 输出：Hello</span></span><br><span class="line">    <span class="comment">//#define PR_DEBUG 0 输出：</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于将函数作为参数">关于将函数作为参数</h2><h3 id="原始函数指针c">原始函数指针C</h3><p>构造函数指针类型时只需将函数名替换为*<strong>变量</strong>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Helloworld</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span>(*func)(<span class="type">int</span> a) = Helloworld;</span><br><span class="line">    <span class="comment">//构造函数指针类型时形参名其实可以不写，保留形参类型就行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者用typedef</span></span><br><span class="line">    <span class="comment">//typedef void(*Helloworldfunc)(int);</span></span><br><span class="line">    <span class="comment">//Helloworldfunc func = Helloworld;</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c中的stdfunction">C++中的std::function</h3><p>用lambda表达式时，如果使用<strong>捕获</strong>功能则不能用原始C的函数指针，原始函数无捕获能力。此时需要使用更加方便的<strong>std::function</strong>，注意包含<strong>头文件functional</strong>，例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; values,<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意只有常量引用才能指向临时变量，lambda表达式是匿名函数，应该属于临时变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : values)</span><br><span class="line">        <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda = [=](<span class="type">int</span> value)<span class="keyword">mutable</span> &#123;a = <span class="number">5</span>; std::cout&lt;&lt; value &lt;&lt; a &lt;&lt; std::endl;&#125;;</span><br><span class="line">    <span class="comment">//注意此处=为复制捕获作用域内所有变量，但不加mutable不能修改捕获的变量</span></span><br><span class="line">    <span class="comment">//加了mutable可以修改捕获的变量，（虽同名）但修改的是复制品，不影响原变量的值</span></span><br><span class="line">    <span class="comment">//使用 &amp;a 捕获a可以修改a的值，因为是引用捕获</span></span><br><span class="line">    forEach(values, lambda);</span><br><span class="line">    </span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于lambda表达式">关于lambda表达式</h2><p>也称<strong>匿名函数</strong>，形如 <strong>[ ] ( ) { } </strong> 或<strong>[ ] ( ) -&gt; { } </strong></p><p><strong>[ ]</strong>中括号内是<strong>捕获</strong>所在作用域的变量（注意<strong>全局变量不需要捕获</strong>）</p><ul><li>=为值传递捕获所有变量（注意用mutable才能修改捕获的复制品值，如上）</li><li>&amp; 为引用传递捕获所有变量，引用不复制，且可以影响原变量</li><li>a, &amp;b为值传递捕获a，引用传递捕获b。（注意值传递捕获需要mutable才能修改复制值）</li><li>特别的，<strong>[this]</strong>表示捕获当前的this指针，常用于class内部的lambda</li></ul><p><strong>( )</strong> 小括号中是函数<strong>形参</strong>；</p><p><strong>{ }</strong> 花括号中是<strong>函数体</strong>；</p><p><strong>-&gt;后</strong>是函数返回值类型，当<strong>返回值是void或者函数体内只有一处return时（返回值明确），可以省略-&gt;，基本都可以省略</strong></p><h2 id="关于namespace">关于namespace</h2><p>首先，<strong>尽量</strong>不要使用using namespacestd等（可以在很局部的作用域使用），防止同名函数调用冲突，用了相当于抹杀namespace作用。</p><p><strong>namespace：命名空间、名称空间。一般在头文件和相应的cpp文件使用，相当于对变量、函数名称套一个“姓”</strong></p><p><strong>使用命名空间中的变量、函数时，需要用全名，（姓：：名），其中：：为域解析符</strong>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.h</span></span><br><span class="line"><span class="comment">//注意尽量少用全局变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> chen&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> a; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//全局变量,所有文件有效，想要在别的文件使用一定要用exterm</span></span><br><span class="line">    <span class="comment">//其他文件引此头文件声明多次，但只在对应的cpp文件定义一次！</span></span><br><span class="line">    <span class="comment">//const全局常量可以直接在头文件直接定义，因为不会改变了！</span></span><br><span class="line">    <span class="comment">//建议不加extern，所有文件各一份，因为在头文件定义了，多次引用该头文件会报重定义！</span></span><br><span class="line">    <span class="comment">//也可和静态全局变量一样在cpp文件内使用，推荐！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不要在头文件定义静态全局变量static char c; ！</span></span><br><span class="line">    <span class="comment">//static静态变量声明与定义同时进行，所以不能与exterm同时出现！</span></span><br><span class="line">    <span class="comment">//静态全局变量只在当前文件有效，所以一般直接放到对应的cpp文件！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> chen&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;    </span><br><span class="line">    <span class="comment">//全局变量头文件声明，cpp文件定义，注意定义时只少一个extern</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="comment">//静态变量cpp文件自己定义自己使用！不关头文件的事！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt; a &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt; b &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt; c &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chen::<span class="built_in">func</span>();</span><br><span class="line">    chen::a = <span class="number">22</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;chen::a&lt;&lt;std::endl;</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">    5  2  c</span></span><br><span class="line"><span class="comment">a: 22</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake常用语句</title>
      <link href="/2022/12/05/Cmake%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
      <url>/2022/12/05/Cmake%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="cmake基本结构">cmake基本结构</h2><p>首先一般先声明Cmake版本要求、项目名称、编译标志：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3</span>.x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (XXXXXXX)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -Werror -std=c++14&quot;</span>)</span><br></pre></td></tr></table></figure><p>设置源码目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (source_dir <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/&quot;</span>)</span><br><span class="line">    <span class="comment">#$&#123;PROJECT_SOURCE_DIR&#125;为CMakeLists.txt所在文件夹位置</span></span><br></pre></td></tr></table></figure><p>可选配置（变量代替所有文件）：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span> (GLOB source_files <span class="string">&quot;$&#123;source_dir&#125;/*.cpp&quot;</span>)</span><br><span class="line">    <span class="comment">#$&#123;source_dir&#125;为上文设置的源码目录；$&#123;&#125;为取值操作；*为通配符；*.cpp所有cpp文件</span></span><br></pre></td></tr></table></figure><p>生成可执行文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span> (HelloWorld <span class="variable">$&#123;source_files&#125;</span>)</span><br><span class="line">    <span class="comment">#$&#123;source_files&#125;为上文设置的汇总源文件</span></span><br><span class="line">    <span class="comment">#所有文件都要编译（生成.o二进制文件），最终链接Link生成名为HelloWorld的可执行文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmake </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎片学习</title>
      <link href="/2022/12/04/%E7%A2%8E%E7%89%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/04/%E7%A2%8E%E7%89%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="碎片学习入口汇总">碎片学习入口汇总</h1><h2 id="英语单词">英语单词</h2><p><strong>只需学习词汇复习课，熟悉词根词缀</strong></p><p><ahref="https://www.bilibili.com/video/BV1rv411b7Xr/?p=4&amp;vd_source=064ee44f6f690b7c190f05d482b5045a">B站入口</a></p><h2 id="c-plus-plus">C plus plus</h2><p><strong>部分课程比较干货</strong></p><p><ahref="https://www.bilibili.com/video/BV1Wd4y1t7fZ?p=62&amp;vd_source=064ee44f6f690b7c190f05d482b5045a">B站入口</a></p><p><ahref="https://www.youtube.com/watch?v=18c3MTX0PK0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">油管入口</a></p>]]></content>
      
      
      <categories>
          
          <category> 碎片学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎片学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传感器时间戳对齐</title>
      <link href="/2022/12/03/Online-Temporal-Calibration-for-Monocular-Visual-Inertial-Systems/"/>
      <url>/2022/12/03/Online-Temporal-Calibration-for-Monocular-Visual-Inertial-Systems/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1id="online-temporal-calibration-for-monocular-visual-inertial-systems">OnlineTemporal Calibration for Monocular Visual-Inertial Systems</h1><p><strong>DOI:</strong> <ahref="https://doi.org/10.1109/IROS.2018.8593603">10.1109/IROS.2018.8593603</a></p><h2 id="基础知识">基础知识</h2><ol type="1"><li>摘要：准确的状态估计是机器人导航、自动驾驶、虚拟现实和增强现实等各种智能应用的基础模块。视觉和惯性融合是近年来流行的六自由度状态估计技术。记录不同传感器测量值的时刻对于系统的稳健性和准确性至关重要（<strong>各传感器的时间对齐</strong>）。在实践中，每个传感器的时间戳通常会受到触发和传输延迟的影响，从而导致不同传感器之间的时间错位（时间偏移）。这种时间偏移极大地影响了传感器融合的性能。为此，我们提出了一种在线方法来校准视觉和惯性测量之间的时间偏移。我们的方法通过联合优化时间偏移、相机和IMU 状态以及 SLAM系统中的特征位置来实现时间偏移校准。此外，该方法是一个通用模型，可以很容易地在几个基于特征的优化框架中使用。仿真和实验结果表明，即使与其他最先进的离线工具相比，我们的校准方法也具有很高的准确性。VIO 与其他方法的比较证明，在线时间校准明显有利于视觉惯性系统。</li><li>一方面，惯性测量使俯仰和侧倾角以及尺度变得可观察。另一方面，惯性测量通过在视觉跟踪失败时弥合差距来提高运动跟踪性能。为了融合来自不同传感器的数据，必须精确知道记录测量值的时间点。</li><li>每个传感器的时间戳通常会受到触发和传输延迟的影响，从而导致不同传感器流之间的时间错位（时间偏移）。因此，传感器的时间同步可能会导致多传感器系统的关键问题。对于视觉惯性系统，相机和IMU之间的时间偏移会极大地影响鲁棒性和准确性。大多数视觉惯性方法假设测量的时间戳在单个时钟下是精确的，这些方法适用于一些严格硬件同步的传感器。</li><li>对于大多数低成本和自组装传感器组，硬件同步不可用。由于触发和传输延迟，相机和IMU之间总是存在时间错位（时间偏移）。时间偏移通常从几毫秒到几百毫秒不等。几十毫秒会导致IMU 序列与图像流完全错位，从而极大地影响视觉惯性系统的性能。</li><li>为此，我们提出了一种在线校准视觉惯性系统的时间偏移的方法。我们假设时间偏移是一个常数但未知的变量。我们通过在线估计它以及相机和IMU 状态以及 SLAM系统中的特征位置来校准它。我们的校准方法是一个通用因子，可以很容易地用于其他基于特征的视觉惯性优化框架。尽管我们使用单目传感器套件来展示我们的方法，但所提出的方法可以很容易地应用于多相机视觉惯性系统。</li><li>我们的贡献如下：<ul><li>我们提出了一种在线校准视觉惯性系统中相机和 IMU之间时间偏移的方法</li><li>我们通过仿真和真实世界的实验展示了在线时间校准的重要性</li><li>开源代码整合进了开源项目中</li></ul></li><li>时间偏移：<ul><li>对于低成本和自组装视觉惯性传感器，摄像机和惯性测量单元之间没有严格的时间同步。由于触发延迟、传输延迟和非同步时钟，生成的时间戳不等于测量采样时刻的时间。因此，不同传感器测量值之间通常存在时间偏移。</li><li>在一般情况下，传感器之间的时间偏移是一个恒定但未知的值（常数）。在一些更糟糕的情况下，传感器使用不同的时钟进行采集，时间偏移会随时间产生漂移（不是常数），这种传感器不适合传感器融合。在本文中，我们考虑了一般情况，其中时间偏移td是一个常量但未知的值。</li><li>图1中描绘了一幅说明时间偏移的图片。在图中，上半部分表示采样瞬间，下半部分显示了时间戳瞬间。由于触发延迟、传输延迟和时钟不同步，生成的时间戳不等于实际采样时间，从而导致摄像机和IMU之间的时间错位。</li><li>具体来说，我们将td定义为：t<sub>IMU</sub> = t<sub>cam</sub> +t<sub>d</sub>，其中时间偏移td是我们应该移动摄像机时间戳的时间量，以便摄像机和IMU数据流在时间上保持一致。td可以是正值或负值。如果相机延迟比IMU长，则td为负值。相反，td为正值。</li></ul></li></ol><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220702152123847.png" /></p><ol start="8" type="1"><li>在图像平面的特征速度：<ul><li>为了使相机和IMU数据流在时间上一致，应根据td向前或向后移动相机图像序列。我们没有移动整个摄像机或IMU序列，而是移动特征点的观测值。</li><li>为此，我们引入了用于建模和补偿时间错位的特征速度。在很短的时间内（几毫秒），摄像机的运动可以被视为匀速运动，故图像特征在短时间内在图像平面上也近似匀速移动。基于这个假设，我们计算特征在图像平面上的速度。如图2所示，I<sub>k</sub>和I<sub>k+1</sub>是两个连续的图像帧。假设摄像机在短时间内[t<sub>k</sub>，t<sub>k+1</sub>]以恒定速度从C<sup>k</sup>移动到C<sup>k+1</sup>。因此，我们近似地认为特征l在这个短时间段内也在图像平面上以恒定速度V<sub>l</sub><sup>k</sup>移动。速度V<sub>l</sub><sup>k</sup>的计算为像素移动值除以时间间隔t。</li></ul></li></ol><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220702173535347.png" /></p><ol start="9" type="1"><li><p>有时间偏移的视觉因子：</p><ul><li><p>在经典稀疏视觉SLAM算法中，视觉测量表示为代价函数中的（重）投影误差。我们通过添加新变量（时间偏移）来扩展经典（重）投影误差。</p></li><li><p>特征有两种典型的参数化。一些算法将特征参数化为其在全局帧中的三维位置，而其他算法将特征参数化为相对于某个图像坐标系的深度或逆深度。接下来，我们分别在这两种参数化中加入时间偏移。</p></li><li><p>（1）三维位置参数化：特征参数化为全局框架中的三维位置（P<sub>l</sub>=[x<sub>l</sub>，y<sub>l</sub>，z<sub>l</sub>]<sup>T</sup>）。在传统中，视觉测量表示为投影误差，</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220704091148248.png" /></p></li><li><p>z<sub>l</sub><sup>k</sup>是对第k帧中特征l的观察。（R<sub>ck</sub><sup>w</sup>，p<sub>ck</sub><sup>w</sup>）是摄像机位姿，将特征P<sub>l</sub>从全局坐标系转换为局部摄像机坐标系。π（·）表示摄像机投影模型，该模型将三维特征投影到图像平面，并产生畸变。</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220704091922829.png" /></p><p>（图3描述了重投影过程。虚线表示没有时间偏移建模的传统重投影过程。实线表示考虑了时间偏移的重投影。黄线表示IMU约束。IMU约束与传统的重投影约束不一致。通过优化td，我们可以在时域中找到与IMU约束匹配的最佳摄像机位姿和特征观测。）</p></li><li><p>摄像机位姿（R<sub>ck</sub><sup>w</sup>，p<sub>ck</sub><sup>w</sup>）受上述公式中视觉测量的约束，它还受到IMU测量的约束。实际上，如果IMU和摄像机之间存在时间错位，则IMU约束与时域中的视觉约束不一致。换句话说，我们应该向前或向后移动摄像机序列，以便摄像机和IMU数据流在时间上保持一致。我们没有移动整个摄像机或IMU序列，而是在时间轴中专门移动特征的观测值。新公式如下：</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220704105711216.png" /></p></li><li><p>V<sub>l</sub><sup>k</sup>是特征在图像平面上的速度，由等式2得出。td是时间偏移未知变量，它改变了特征在时域中的观测值。通过优化td，我们可以在时域中找到与IMU约束匹配的最佳摄像机位姿和特征观测。</p></li><li><p>（2）深度参数化：该特征也可以参数化为相对于图像坐标系的深度或逆深度。我们以图像i 中的深度 λi 为例。从图像 i 到图像 j 的传统重投影误差写为：</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220704121943301.png" /></p></li><li><p>首先将特征l投影到全局帧中，然后将其反投影到局部摄像机帧 j中的图像平面上。残差是观察和反投影位置之间的偏移。</p></li><li><p>与等式4类似，我们考虑时间偏移变量td到方程中：</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220704122123247.png" /></p></li></ul></li><li><p>带时间偏移的优化：</p><ul><li><p>通过利用上述视觉因子，我们可以轻松地将时间校准函数添加到典型的基于视觉惯性优化的框架中。在这些框架中，视觉惯性SLAM被表述为一个非线性优化问题，将视觉和惯性测量紧密耦合。如图4所示，多个摄像机帧和IMU测量被捆绑为“束”，“束”大小决定计算的时间复杂度。局部束调整（BA）联合优化摄像机和IMU状态以及特征位置。我们可以很容易地将提出的加入时间偏移优化的视觉因子添加到这种框架中。具体而言，整个状态变量增加时间偏移优化量，状态变量定义为：</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220705090919710.png" /></p></li><li><p>其中，第k组预积分的IMU状态由全局坐标系中的位置p<sub>k</sub><sup>w</sup>、速度v<sub>k</sub><sup>w</sup>、方向R<sub>k</sub><sup>w</sup>和局部body坐标系中的IMU偏差b<sub>a</sub>、b<sub>g</sub>组成。特征P<sub>l</sub>由全局坐标系中的3D位置或相对于特定图像坐标系的深度参数化。整个问题被表述为一个包含IMU传播因子、重投影因子以及某个先验因子的代价函数。因此，我们使用加入时间偏移变量的视觉因子来实现时间偏移校准，</p><p><imgsrc="https://gitee.com/haolin12/pixgo_tuchuang/raw/master/img/image-20220705090957807.png" /></p></li><li><p>e<sub>B</sub>（z<sub>k+1</sub><sup>k</sup>，X）是IMU传播的误差项。B是所有IMU测量值的集合。e<sub>C</sub>（z<sub>l</sub><sup>j</sup>，X）是提出的包含时间偏移的视觉（重）投影误差，C是在图像帧中观察到至少两次的特征集。误差由其协方差的逆P加权。{e<sub>p</sub>，H<sub>p</sub>}是来自先验知识和边缘化的先验信息。只有少量测量值和状态保留在优化窗口中，而其他测量值和状态则被边缘化并转换为先验。然后使用高斯-牛顿法高效地优化非线性最小二乘函数。</p></li></ul></li><li><p>时间偏移补偿：</p><ul><li>在每次优化之后，我们通过移动后续视觉流的时间戳来补偿时间偏移，因为t′<sub>cam</sub>=t<sub>cam</sub>+t<sub>d</sub>。然后，系统估计补偿视觉测量和惯性测量之间的δ<sub>td</sub>。δ<sub>td</sub>将在后续数据流中迭代优化，并收敛到零。随着时间间隔δ<sub>t</sub>的减小，我们的基本假设（特征在短时间间隔内在图像平面上以恒定速度移动）越来越合理。即使在开始时存在巨大的时间偏移（例如数百毫秒），该过程也会逐渐从粗到细进行补偿，直至收敛到零。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> VINS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> VINS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
